# RAG 전략 명세

## 1. 수집(Ingest)
- 코드: `git ls-files`/`.gitignore` 준수, 언어/경로/sha 메타, 큰 파일 스킵/샘플링.
- 문서: README, docs/, ADR, API 스키마.
- 웹: 검색 API → 수집 → 중복제거 → 요약 → 검증 후만 저장(출처/도메인/ETag/TTL/신뢰점수).
 - 지식(승격): `/knowledge`로 입력된 고신뢰 지식만 별도 보관(검증/점수화 후 trustScore 임계 이상만 사용).

## 2. 청킹(Chunking)
- 코드: 함수/클래스 범위 우선, 토큰 예산 기반 슬라이딩 윈도우 보완.
- 문서: 헤딩/문단 단위, 앵커/링크 유지.
- 심볼테이블: export/타입/엔드포인트, 교차참조 그래프.

## 3. 인덱싱(Index)
- 초기 벌크 → 증분(fs watch/git 상태), 배치 처리/배압.
- 용어 인덱스(BM25/FTS5) + 벡터 인덱스(외부 VectorStore) 병행.
- 임베딩 캐시(sha 기준), 실패/재시도 큐.

## 4. 검색(Retrieve)
- 하이브리드: BM25 상위 K ∪ 벡터 상위 K → LLM 리랭커로 최종 N.
  - 인터페이스: `internal/rag/retriever.Retriever` (`Retrieve(ctx, projectID, query, k)`)
  - 기본 구현: BM25(FTS5) 기반 `BM25Retriever` — 저장소의 `Search(projectID, query, k)`를 위임 호출
  - 하이브리드 구현: `HybridRetriever` — BM25와 KNN 결과를 합집합으로 병합 후 `score = bm25 + α·knn`으로 재정렬(중복 경로는 상위 스코어의 범위를 유지). `α`는 `MYCODER_HYBRID_ALPHA`(기본 0.5)로 조정 가능
  - 의도 분류: `internal/rag/planner.Classify`가 `nav|explain|edit|research`를 분류하고, `RetrievalK`로 K를 의도별로 조정(nav=기본, explain≥7, edit≥8, research≥10)
  - 쿼리 플래닝: 의도(탐색/설명/편집/수정/리서치) 분류 → 증거 컨텍스트 구성 규칙 차등 적용.
  - 멀티홉: 심볼 그래프 확장(정의 → 참조/사용처).
 - 지식 결합: Knowledge에서 trustScore 상위 항목을 우선 컨텍스트로 주입.

## 5. 답변 합성(Compose)
- 프롬프트 템플릿: 역할/규칙(인용 강제, 라인 범위), 코드 스니펫 제한, 툴콜 허용.
- 인용 형식: `path:start-end` + 요약 캡션.
- `/chat` 연동: 요청에 `projectID`가 포함되면 상위 K 검색 결과를 시스템 메시지로 주입(파일:라인+프리뷰)
  - 가능 시 코드 블록 포함: ```lang ...```로 라인 범위 주변(±2줄) 포함하여 최대 24줄, 전체 컨텍스트 예산 3k chars 제한.
  - LLM 지침: "근거가 부족하면 불확실하다고 말할 것" 및 파일/라인 인용 유지.
  - 지식(승격) 결합: Knowledge(trustScore 상위)의 제목/핵심 텍스트를 우선 주입, 동일 파일/주장 중복 제거.
  - 리랭크(구현): 검색 스코어에 trustScore(경로 일치)를 가중치로 더해 재정렬, 경로 중복 제거 후 상위 K.

## 6. 품질 통제
- 셀프체크 프롬프트(일관성/근거 확인), 중복 컨텍스트 제거, 테스트: 청커/리트리버 계약/회귀.
 - 지식 승격 파이프라인: vet/decay/reverify 배치, 핀/정리 정책.
 - 백그라운드 큐레이터: `MYCODER_CURATOR_INTERVAL`(기본 10m), `MYCODER_KNOWLEDGE_MIN_TRUST`로 정리 임계 설정.
 - 리랭크: score = bm25 + α·trustScore + β·freshness + γ·diversity (다양성/중복 제어).

## 7. 부족시 보강(Web Enrichment)
- 신뢰도 임계 미만 시 검색 트리거 → 요약/정규화 → 수동/자동 승인 정책.

## 8. 대화 메모리 전략(요약)
- 슬라이딩 윈도우: 최근 N 토큰 유지. 모델/명령에 따른 가변 예산.
- 요약 버퍼: 오래된 메시지를 주제별로 압축(결정/명령/근거 파일 경로 보존). 필요 시 재압축.
- 장기 저장: 검증된 인사이트/패턴은 Document로 영속화하여 재인덱싱(Conversation과 분리).
## 0. 지식 큐레이션/승격(Strategy)
- 수명주기: 수집 → 전처리 → 검증 → 점수화(trustScore) → 승격 → 사용 → 피드백 → 감쇠/정리.
- 검증: 다원 검증(다수 출처/공식 문서 가중), 코드 주장 시 컴파일/테스트/벤치 증거 반영.
- 점수화: 출처 신뢰도×일관성(훅 그린)×테스트/벤치×참조수×신선도(+핀).
- 승격: 임계값 이상·핀은 우선 사용. 충돌/모순은 보류/리뷰 루트.
- 정리: TTL/미사용/낮은 점수는 정리(decay), 상위는 주기적 재검증(reverify).
- 검색 결합: 현재 쿼리와 과거 대화 요약/메시지를 임베딩 검색해 관련 부분만 컨텍스트로 주입.
- 삭제/TTL: 일정 기간 경과/저활성 세션은 요약만 유지하고 원문 삭제. 고정(pinned) 세션은 예외.

## 9. 다국어(한글)·코드 임베딩 전략 (Qwen3 Coder 30B 정책 포함)
- 기본 경로: 한글 질의를 그대로 처리하는 하이브리드 검색(BM25 + 코드 전용 임베딩).
- 폴백 경로(조건부): 결과가 부족하면 한글→영어 번역 후 동일 파이프라인으로 재시도.
  - 임계치: 상위 히트 수 < K/2 또는 상위 스코어 < θ일 때 번역 경로 실행.
  - 번역 규칙: 코드 식별자/리터럴은 보존(백틱/따옴표로 보호), 기술 용어는 가급적 보존.
- 다중 임베딩 옵션: 질의에 다국어 임베딩(예: text-embedding-3-large)과 코드 임베딩을 병렬 조회 후 합집합을 가중 재랭킹.
- 이웃 확장: 함수/클래스 경계 기반으로 상하 문맥을 10~15% 오버랩 포함하여 확장.
- 생성 단계: 인용은 `path:start-end` 유지, 답변 언어는 질의에 맞춰 한국어 우선.
- 채팅 모델: `MYCODER_CHAT_MODEL=qwen3-coder-30b-a3b-instruct` 고정.

## 10. 코드 전용 임베딩 도입 시 고려사항
- 모델/차원: 차원(d) 상이 시 자동 분리, 동일 차원 모델 혼류 방지 위해 "모델 스코프" 필터 필요.
- 저장/검색 스코프: VectorStore 검색 시 `project_id + dim + model`로 범위 제한(모델 혼합 검색 방지).
- 배치/레이트리밋: 임베딩 배치 크기/타임아웃/재시도 백오프를 환경변수로 조정.
- 청킹: 토큰 기준 + 10~15% 오버랩, 언어 경계 우선. 현재 문자/라인 기반은 단계적으로 교체.
- 하이브리드 가중치: `α`(KNN 가중) 재튜닝 필요. 환경변수 `MYCODER_HYBRID_ALPHA`로 조정.
- ANN 백엔드: 데이터/차원 증가 시 pgvector/Qdrant 등 ANN로 이전(현 SQLite는 선형 스캔).

### 환경변수(제안)
- `MYCODER_TRANSLATE_KO_EN=1` 번역 폴백 활성화
- `MYCODER_TRANSLATOR_MODEL` 번역 모델 지정
- `MYCODER_TRANSLATE_TIMEOUT_MS` 번역 타임아웃(ms)
- `MYCODER_EMBEDDING_PROVIDER`(예: openai, codexembed) 및 `MYCODER_EMBEDDING_MODEL`

### 품질/검증
- 리더보드: KO 질의 세트로 직접 vs 번역 vs 다중임베딩 성능(k@5/10, MRR) 비교.
- 지연/비용: 평균·95p 응답시간, 임베딩 호출 수 측정.
- 회귀: 번역 품질 드리프트와 랭킹 품질 회귀 테스트.
